# MVC 패턴
## JSP에서 MVC 패턴 흐름
![image](https://github.com/GYUNGAEEEE/WebProgramming/assets/158580466/d535348f-a9d3-4c1c-a49c-4cf9a34d752d)

웹 브라우저에서 요청이 서버에 도달하면, 서버는 해당 요청에 대한 처리를 담당할 Setvlet(컨트롤러)를 생성한다.
Servlet은 요청을 분석하여 수행해야 하는 기능을 확인하고, 이를 위해 모델을 활용하여 비즈니스 로직을 처리한다.

모델은 컨트롤러로부터 요청을 받아 해당 기능의 처리를 수행하며, 필요한 경우 외부 자원(예: 데이터베이스)을 사용하여 데이터를 가져올 수 있다.
모델은 처리 결과를 생성하고, 이를 컨트롤러에 반환한다.

컨트롤러는 처리 결과를 클라이언트에 보여주기 위해 JSP 파일을 활용한다. 컨트롤러에서는 JSP 파일에 전달할 데이터를 설정한 후, 해당 JSP 파일을 호출한다.
설정된 데이터는 주로 request나 session 객체에 저장되며, JSP 파일에서는 이 데이터를 활용하여 동적인 HTML을 생성한다. JSP 파일은 Tomcat에서 처음 요청 시에 컴파일되고, 이후에는 컴파일된 서블릿을 사용한다.
서블릿 객체는 초기화(init()) 과정을 거친 후 request나 session 객체에 저장된 데이터를 활용하여 응답 HTML 문서를 생성하고 클라이언트 측으로 응답해준다.

참고로 REST API를 사용하는 경우 JSON 또는 XML 형식으로 데이터를 클라이언트에 응답한다.
***
## JSP에서 MVC패턴을 구현하는 방법
1. 서비스하는 기능마다 서블릿을 정의하고 등록 -> 요청마다 서블릿을 만들고 매핑되는 URL패턴을 설정
   
클라이언트에서 서버로 'A'라는 기능을 요청한다면, 그 'A'기능을 처리하기 위한 서블릿이 있다. 또, 다른 기능에 대한 요청을 한다면 그 요청을 받아주는 서블릿이 있는, 서블릿이 계속 등록이 되는 방식이다.

2. FrontController를 만들어 모든 요청을 받는 서블릿을 정의하고 등록

URL매핑에 /를 이용하여 하나의 서블릿이 모든 요청을 받는다. 즉, 어떤 URL 패턴으로 요청이 들어오는지 상관없이 하나의 서블릿에서 다 받아들인다.   
요청 URL 또는 파라미터로 전달된 명령을 이용하여 처리할 비즈니스 로직을 선택한다. 명령에 따라 특정 Service(Action, Handler, Process)에서 처리를 할 수 있도록 제어를 한다. Service는 회원가입, 로그인, 게시판 등의 기능(비즈니스 로직)과 관련된다.
이들과 DB의 연동을 위한 DAO, DTO도 함께 활용할 수 있다.
FrontController에서 요청을 분석하고 비즈니스 로직을 처리 후 브라우저에 응답 또는 적절한 뷰를 선택하여 응답한다.
***
## FrontController패턴으로 MVC 적용해보기
### 모델 개념 준비
- AddService.java
```java
package exammvc.model;

public class AddService {
	public int add(int n1, int n2) {
		return n1 + n2;
	}
}
```
- MinService.java
```java
package exammvc.model;

public class MinService {
	public int min(int n1, int n2) {
		return n1 - n2;
	}
}
```

### 핸들러 개념 준비
- CommandHandler.java
```java
package exammvc.controller;

import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public interface CommandHandler {

	public String handlerAction(
			HttpServletRequest request, 
			HttpServletResponse response) throws ServletException, IOException;
}
```
- AddHandler.java
```java
package exammvc.controller;

import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import exammvc.model.AddService;

public class AddHandler implements CommandHandler{
	
	private AddService addService = new AddService();

	@Override
	public String handlerAction(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		int n1 = Integer.parseInt(request.getParameter("n1"));
		int n2 = Integer.parseInt(request.getParameter("n2"));
		
		int result = addService.add(n1, n2);
		
		request.setAttribute("result", result);
		
		return "/WEB-INF/add.jsp";
	}
	
}
```
- MinHandler.java
```java
package exammvc.controller;

import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import exammvc.model.MinService;

public class MinHandler implements CommandHandler{
	
	private MinService minService = new MinService();

	@Override
	public String handlerAction(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		int n1 = Integer.parseInt(request.getParameter("n1"));
		int n2 = Integer.parseInt(request.getParameter("n2"));
		
		int result = minService.min(n1, n2);
		
		request.setAttribute("result", result);
		
		return "/WEB-INF/min.jsp";
	}
	
}
```
사용자가 브라우저를 통해 특정 URL을 요청한다.
요청이 들어왔을 때, 어떤 처리를 할지 결정하는 주체로서 컨트롤러가 동작한다. 요청을 구분하여 각각에 맞는 처리 방식을 결정한다.
요청이 "add"인 경우 AddHandler가 선택되고, "min"인 경우에도 동일한 방식으로 해당 핸들러(MinHandler)를 선택한다.

선택된 핸들러는 AddService나 MinService와 같은 서비스를 통해 실제로 요청을 처리한다.
처리 결과는 request 객체에 저장된다. 이 객체는 서버 측에서 클라이언트로부터의 요청에 대한 정보를 담고 있는 객체이다.
처리된 결과를 토대로 어떤 JSP 파일을 사용할지를 결정하기 위해, view 경로를 반환한다.

선택된 JSP 파일(add.jsp 또는 min.jsp)은 request 객체에 담겨 있는 데이터를 이용하여 표현식 처리를 수행한다.
JSP는 Java 코드와 HTML을 혼합하여 동적으로 웹 페이지를 생성하는 기술을 제공한다.
JSP 파일에서 생성된 결과물은 브라우저에 응답으로 전송되고, 브라우저는 해당 응답을 받아 화면에 표시하게 된다.
### 직접 핸들러 객체 생성하는 방법
```java
package exammvc.controller;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class FrontController extends HttpServlet {
	
	private Map<String, CommandHandler> commandHandlerMap = new HashMap<>();
	
	@Override
	public void init() throws ServletException {
		commandHandlerMap.put("/add", new AddHandler());
		commandHandlerMap.put("/min", new MinHandler());
	}
	
	@Override
	public void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		System.out.println("Controller가 요청 분석");
		String requestURI = req.getRequestURI().toString();
		System.out.println("요청 URI: " + requestURI);
		
		String command = requestURI.substring(req.getContextPath().length());
		System.out.println("command: " + command);
		
		CommandHandler handler = null;
		String viewPage = null;
		
		if(requestURI.indexOf(req.getContextPath()) == 0) {
			handler = commandHandlerMap.get(command);
			viewPage = handler.handlerAction(req, resp);
			System.out.println("Model관련(비즈니스 로직) 동작");
		}
		
		System.out.println("Controller가 결과 데이터를 보여줄 뷰로 포워딩");
		req.getRequestDispatcher(viewPage).forward(req, resp);
	}
	
}
```
FrontController만이 클라이언트의 요청을 받아 처리하고 응답을 줄 수 있는 Servlet이다.
이 Servlet은 요청이 들어왔을때 요청이 무엇인지 구분해야 하고, 그 요청에 맞는 기능으로 연결을 해주어야 한다.

Servlet은 commandHandlerMap이라는 HashMap을 정의한다.
Servlet 객체가 생성되었을때 최초에 한 번 호출되는, 그리고 초기화하는 메서드 init()에서는 commandHandlerMap에 각각의 문자열과 매핑되는 Handler 객체를 put()한다.

service()는 브라우저에서 요청하는 내용이 처리될 때 동작한다.
요청 URI(requestURI)에서 "/add", "/min"에 해당하는 부분(command)을 가져와 요청에 맞는 handler를 get()한다.
선택된 handler의 handlerAction()를 동작한다. 이는 다형성으로, CommandHandler 타입으로 선언된 handler는 그 레퍼런스 타입(AddHandler 또는 Minhandler)에 따라 각자의 클래스에 구현된 handlerAction()를 실행하는 것이다.
req안에는 결과 데이터가 담겨 있으며, viewPage에는 handlerAction()에서 반환한 JSP 파일에 대한 경로를 담은 문자열이 저장된다.

마지막으로 해당 JSP 파일로 forwarding하면서 결과 데이터가 유지되고 있는 req, resp를 그대로 전달해주고 있다.
### 서블릿 등록
- web.xml
```xml
<servlet>
	<servlet-name>frontController</servlet-name>
	<servlet-class>exammvc.controller.FrontController</servlet-class>
</servlet>

<servlet-mapping>
	<servlet-name>frontController</servlet-name>
	<url-pattern>/</url-pattern>
</servlet-mapping>
```
frontController를 서블릿 등록하고 /(디폴트, 모든 요청)을 받도록 매핑해주었다.
### 뷰 작성 등록
- add.jsp
```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>덧셈결과</title>
</head>
<body>
<h1>View 결과 페이지</h1>
덧셈 결과: ${ result }
</body>
</html>
```
- min.jsp
```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>뺄셈결과</title>
</head>
<body>
<h1>View 결과 페이지</h1>
뺄셈 결과: ${ result }
</body>
</html>
```
이 JSP 파일(view)들은 브라우저에서 직접적으로 요청하지 못하도록 서버 내에서만 처리하는 경로 'WEB-INF' 하위에 저장한다.
AddHandler와 MinHandler가 처리하고 반환하는 경로가 선택된 view, add.jsp와 min.jsp를 의미한다.
***
## 프론트 컨트롤러와 핸들러 관계
![KakaoTalk_20240312_230819197](https://github.com/GYUNGAEEEE/WebProgramming/assets/158580466/5c10edbf-c827-4d89-abc9-bfec14bfa5cf)

request 요청을 했을 때 FrontController가 받아서 처리를 한다. 
요청이 무엇이냐에 따라 CommandHandler를 구현한 AddHandler 또는 MinHandler 구현체를 선택해서 그 handler로 handler action/process/business logic을 처리한다.
처리된 결과는 request 객체에 저장되어 전달된다.

> '/servletex'는 contextPath
- http://localhost:8081/servletex/add?n1=10&n2=20
```
Controller가 요청 분석
요청 URI: /servletex/add
command: /add
Model관련(비즈니스 로직) 동작
Controller가 결과 데이터를 보여줄 뷰로 포워딩
```
- http://localhost:8081/servletex/min?n1=10&n2=20   
```
Controller가 요청 분석
요청 URI: /servletex/min
command: /min
Model관련(비즈니스 로직) 동작
Controller가 결과 데이터를 보여줄 뷰로 포워딩
```

> 참고자료: https://www.youtube.com/watch?v=D6EIkCNEPSQ&t=1051s
