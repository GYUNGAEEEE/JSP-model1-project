# properties 및 Java reflection
## 핸들러를 생성하여 Map에 put하는 부분을 변경
```java
@Override
public void init() throws ServletException {
  commandHandlerMap.put("/add", new AddHandler());
  commandHandlerMap.put("/min", new MinHandler());
}
```
위 코드를 properties파일과 java reflection을 이용하는 형태로 변경해본다.
### properties파일 생성 및 URL과 핸들러 매핑 정보 작성
> [General]-[Untitled Text File]을 선택하고, 파일 작성 후 [Save As]하여 *.properties로 저장한다.

- handler.properties
```properties
/add=exammvc.controller.AddHandler
/min=exammvc.controller.MinHandler
```
"/add" 문자열과 매핑될 정보는 exammvc.controller 패키지에 들어있는 AddHandler 클래스다.
어떤 요청에 어떤 클래스가 동작해야 되는지 설정해 놓는다.
***
## 초기화 파라미터 활용
web.xml 파일에 초기화 파라미터로 properties파일 경로 등록
- web.xml(4~7라인 추가)
```xml
<servlet>
  <servlet-name>frontController</servlet-name>
  <servlet-class>exammvc.controller.FrontController</servlet-class>
  <init-param>
    <param-name>handlerProperties</param-name>
    <param-value>/WEB-INF/handler.properties</param-value>
  </init-param>
</servlet>

<servlet-mapping>
  <servlet-name>frontController</servlet-name>
  <url-pattern>/</url-pattern>
</servlet-mapping>
```
frontController Servlet이 생성될 때 init()에서 이 값을 사용할 수 있다.
***
## FrontController의 init메서드 수정
초기화 파라미터로부터 properties파일 정보를 불러들여 핸들러 객체 생성 및 URL과 매핑
- FrontController.java
```java
@Override
public void init() throws ServletException {
  //commandHandlerMap.put("/add", new AddHandler());
  //commandHandlerMap.put("/min", new MinHandler());
  
  //초기화 파라미터를 이용하여 Properties 불러오기
  String contextConfigFile = this.getInitParameter("handlerProperties");
  Properties properties = new Properties();
  FileInputStream fis = null;
  try {
    String contextConfigFilePath = this.getServletContext().getRealPath(contextConfigFile);
    fis = new FileInputStream(contextConfigFilePath);
    properties.load(fis);
  } catch(IOException e) {
    e.printStackTrace();
  } finally {
    if(fis != null) {
      try {
        fis.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
  }
}
```
handlerProperties에 연결된 <param-value>값("/WEB-INF/handler.properties")을 가져와 contextConfigFile에 저장한다.
java.util.Properties의 객체를 생성하고, 입력 스트림을 생성한다.

handler.properties의 실제 파일 시스템 상 위치를 얻기 위해 getRealPath()를 사용한다.
파일의 절대 경로가 contextConfigFilePath에 저장된다.
파일의 내용을 읽어오기 위해 입력 스트림을 생성해 properties 객체에 로딩(load())한다.

properties는 '='을 기준으로 앞에 오는 문자열은 Key값, 뒤에 오는 문자열은 Value값의 Map<String, String> 형태로 관리한다.
- FrontController.java
```java
public class FrontController extends HttpServlet {
  ...
  //핸들러 객체 생성 및 Map에 등록
  Iterator<Object> propIt = properties.keySet().iterator();
  while(propIt.hasNext()) {
    String command = (String)propIt.next();
    String handlerClassName = properties.getProperty(command);
    try {
      Class<?> handlerClass = Class.forName(handlerClassName);
      commandHandlerMap.put(command, (CommandHandler)handlerClass.newInstance());
    } catch(ClassNotFoundException e) {
      e.printStackTrace();
    } catch(IllegalAccessException e) {
      e.printStackTrace(); 
    } catch(InstantiationException e) {
      e.printStackTrace();
    }
  }
}
```
properties로부터 Key값의 Set("/add"와 "/min"의 Set)만 가져온다. 그리고, 반복자를 이용해 Value를 읽어온다.
```java
Class<?> handlerClass = Class.forName(handlerClassName);
commandHandlerMap.put(command, (CommandHandler)handlerClass.newInstance());
```
이 부분이 java reflection 활용하는 것이다. handlerClassName을 가지고 클래스의 정보를 읽어왔다.
그 클래스 정보를 바탕으로 newInstance()해 객체를 생성하고, 우리가 구현한 모든 handler는 CommandHandler의 인터페이스를 상속하고 있기 때문에 형변환하여 commandHandlerMap에 put()해준다.
즉, 클래스 이름만으로 클래스를 불러와서 객체를 생성하고 있다.

이런 방식을 사용하면 새로운 handler가 추가되더라도 Java 코드를 직접 수정하지 않고도 properties 파일에 작성해주면 자동 등록된다.
***
# MVC 패턴
앞서 구현해본 FrontController패턴의 MVC 구조는 중요하다.
Spring Framework에서 제공되는 Spring MVC와 유사하며, Spring MVC는 프론트 컨트롤러 패턴을 기반으로 MVC구조를 제공한다.
개발자가 해당 구조에 맞춰서 필요한 부분만 구현하며 개발을 진행하기 때문에 편리하다.
***
# 곱셈 기능 추가해보기
- MulService.java
```java
package exammvc.model;

public class MulService {
	public int mul(int n1, int n2) {
		return n1 * n2;
	}
}
```
- MulHandler.java
```java
package exammvc.controller;

import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import exammvc.model.MulService;

public class MulHandler implements CommandHandler {
	
	private MulService mulService = new MulService();

	@Override
	public String handlerAction(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		int n1 = Integer.parseInt(request.getParameter("n1"));
		int n2 = Integer.parseInt(request.getParameter("n2"));
		
		int result = mulService.mul(n1, n2);
		
		request.setAttribute("result", result);
		
		return "/WEB-INF/mul.jsp";
	}
	
}
```
- Mul.jsp
```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>곱셈결과</title>
</head>
<body>
<h1>View 결과 페이지</h1>
곱셈 결과: ${ result }
</body>
</html>
```
- handler.properties
```properties
/add=exammvc.controller.AddHandler
/min=exammvc.controller.MinHandler
/mul=exammvc.controller.MulHandler
```
